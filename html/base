0)
- <input type='password'> {пароль}
- <input type='checkbox'> {поле галочка, checked - пустой атрибут (<input type='checkbox' checked/>)}
- <input type='radio'> {группируется по name, значения группы задаются в value, checked - выделение по умолчанию}
- <input type='file'> {имя - обязательный аттрибут, для формы обязательно задать enctype='multipart/form-data'}
- <input type='hidden'> {скрытые данные, не выводятся}

0)Таблица
- имеет свойство cellpadding=value, данное свойство отсутствует в css

1)Подпись:
- <label><input/></label> {если щелкнуть по подписи мышкой, то курсор переместится в соответствующее поле}
- <label for='some-id'> <input id='some-id'/> {привязка подписи с помощью атрибута for}

2) многострочное текстовое поле <textarea> 
- атрибуты:
	- rows\cols
	- контект как value
3) выпадающий список <select>
- одиночный выбор
<select>
	<option value='value1'>option-text-1</option>
	<option value='value2'>option-text-2</option>
</select>
{Если при отправке формы у выбранного варианта задан value, то на сервер отправится значение этого атрибута. В противном случае будет отправлен текст подписи.}
- мультивыбор
	- атрибут multiple
	- дописать[] в name select'a (т.е. взаимодействие как с массивом)
	- size (высота мультивыбора)

css
 - input[type="submit"] - {селектор по типу}
- id {идентификатор, уникален в пределах формы]}

Атрибуты
1)выравнивание текста:
- text-align {left;center;right}
- vertical-align {top; middle;bottom}
2)Цвет
- background-color - цвет фона
- color - цвет
- border-color - цвет рамки
3)Размеры
- px {абсолютные}
- % {относительные}
- auto {расчет параметров по умолчанию}
p.s. проценты при задании высоты не работают
4) явное указание значения стилей через атрибут style=''

Формы
1)параметры:
- action {адрес отправки формы}
- method {метод отправки формы}
- get {посылает данные в строке запроса}
- post {посылает данные в теле http-запроса}

Input
1)параметры:
- type {text;}
- name 
- value {значение по умолчанию}

font-family:'Tahoma' - шрифт

class - определение класса тега

CSS
1)селекторы
- имена тегов (tag{})
- классы\псевдоклассы(.class{})
2)приоритеты
- !important;
- style (в теге)
- id
- class
- tag type
- наследование
3)виды:
  selector {simple}
  selector selector {контекстные селекторы}
  selector+selector {соседние селекторы}
  selector selector+selector{контекстные+соседние} 
  selector>selector {дочерний селектор(чем отличаются контекстные и дочерние селекторы)}
  	потомок - любые элементы расположенные внутри родительского элемента
	дочерние - ближайшие потомки
  selector:pclass {селекторы по псевдоклассам, nth-child}	
  	td:hover em - при наведении на строку подсвечивается <em>
  selector[attribute] or selector[attribute = 'value'] { селектор по атрибутам }
  #selector {выбор по id}

display - определяет тип элемента {блочный; строчный;..}
position - позиционирование элемента {absolute (исключаются из потока, место где распологаются считается пустым)}

Наследование работает не для всех свойств, не наследуются ширина, высота, отступы, режим позиционирования и другое
{background, border, padding, margin, width, height, position}

Наследуются в первую очередь свойства определяющие параметры отображения текста:
{font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-spacing, direction}
а так же:
{list-style (тип макеров), cursor, visibility, border-collapse}

inherit - определяет значение родительского компонента (принудительное наследование)

<p class="blue red">
.blue{}
.red{приоритетнее}
Cелекторы у правил одинакового типа, и соответственно обладают одинаковой специфичностью. В таком случае более высоким приоритетом обладает то правило, которое расположено в CSS-коде ниже.

но:
p.blue{приоритетнее, т.к. более специфичный}
.red{}
Чем меньшее количество элементов потенциально может выбрать селектор, тем он специфичнее.

clear:both; ???

<span> - просто тестовый блок
Размеры текста:
  - относительные величины
    em - относительная еденица измерения (1em обычно равен длине M)
    % - проценты
  - абсолютные величины
    px - пиксели
    pt - пункты
    small\large - обычно не используют

text-indent - отступ абзаца
font-size - размер шрифта
font-weight - жирность основные {bold, normal}, дополнительные:{bolder, lighter, 100, 200, 300, 400, 500, 600, 700, 800, 900}
font-style - начертание текста {normal, italic}
font-family - семейство шрифта ("Times New Roman") {serif (шрифт с засечками), sans-serif (шрифт без засечек)}

body{ font-family: "Verdana", "Arial", serif; } - поиск шрифта с лево на право

color - задает цвет {#FF9900, red, rgb{255,255,0}}
text-decoration - оформление текста, значения можно примнять через пробел
- underline - подчеркивание
- line-through - зачеркивание
- overline - черта сверху
- blink - мигание
- none - убирает вышеперечисленные еффекты

как отобразить пунктирное подчеркивание?
1) убрать обычное подчеркивание
2) задать нужный цвет 
3) border-bottom - dashed
4) :hover

text-transform - регистр символов
- lowercase - все строчные
- uppercase - все прописные
- capitalize - каждое слово начинается с прописной
- none - отменяет значение регистра

white-space - управление пробелами
- nowrap - отображать весь текст одной строкой без переносов
- pre - сохраняет пробелы и переносы как в исходном коде аналогично тегу <pre>
- pre-wrap - pre + добавляет автоматические переносы если текст не помещается
- normal - режим по умолчанию

text-align - горизонтальное выравнивание текста
- left
- right
- center
- justify (по ширине)

vertical-align - вертикальное выравнивание
- top
- middle
- bottom
- baseline (по базовой линии(по умолчанию))
- sub (аналог <sub>h20)
- super (аналог <sup>x2)

line-height - высота строки, межстрочный интервал
- 1.5, 2 множитель
- проценты, 12px, 2em
- normal - автоматический расчет



Graceful degradation
Progressive enhancement
Responsive design
-fluid layout
-responsive queries
-fluid  images

<!-- Блочные элементы -->

Блочные элементы - прямоугольные области на странице:

1) до и после блочных элементов существует перенос строки
2) блочными элементами можно задаеть ширину, высоту
3) занимают все допустимое пространство по горизонтали

<p> <h1> <h2> <ul> <div>

блочные элементы предназначены для разметки крупных блоков и создания сетки

<!-- Строчные элементы -->

Строчные элементы распологаются друг за другом в одной строке, при необходимосте строка переносится.

1) до и после строчного элементы отсутствуют переносы строки
2) ширина и высота строчного элемента зависит только от ео содержания, задать размеры с помощью css нельзя
3) можно задавать только горизонтальные отсутпы, частично реагируют на горизонтальные отступы, визуально увеличиваются, но без увеличения занимаемого места (не отталкивают другие элементы)

<a> <strong> <em> <span>

предназначены для оформления текста на уровне небольших фраз и отдельных слов.

<!-- Padding -->

padding - задает внутренние отступы элементы - отступы от внешней границы, иногда называют полями

для строчных элементов лучше не задавать вертикальных отступов, т.к. они ведут себя непредсказуемо

margin: all
margin: up-down left-right
margin: up left-right down
margin: up right down left

<!-- Margin -->

margin - задает внешние отступы элемента - отступы от внешней границы до границ родительского или до соседних элементов

строчные елементы реагируют только на горизонтальные отступы

margin: all
margin: up-down left-right
margin: up left-right down
margin: up right down left

<!-- Border -->

Рамка - можно задавать блочным и строчным элементам
типы рамки: solid | dashed | dotted

<!-- Стандартная блочная модель -->

Область, занимающая блочным элементом, складывается из его ширины и высоты содержания, внутренним и внешним отсутпом, ширины рамокю

https://htmlacademy.ru/assets/course9/block_model.png

<!-- Схлопывание внешних отступов -->

Вертикальные - схлопываются 
Горизонтальные - складываются

<!-- Выпадание внешних отступов -->

Внешние и внутренние отступы всегда складываются.

Если родительскому элементу, с нулевым вертикальным отступом, поместить элемент с вертикальным отступом, то родительский элемент прижмется к дочернему, а у родительского элемента появится отступ.

Чтобы избавится от выпадания, внешнему элементу можно добавить внутренний отсутп, или добавить ему рамку.

<!-- Отцентрировать блочный элемент -->

1. Задать ширину меньшую ширины родительского элемента.
2. Задать для внешних отступов справа и слева значение auto.

<!-- Ширина по умолчанию и 100% ширина -->

width - задает ширину содержания, без учета рамок и отсутпов. Общая ширина складывается из ширины содержания, внутренних отступов, ширины рамки.

задание ширины:
1) width:auto - блок занимает всю родительскую ширину, содержание автоматически уменьшается на ширину отступов и рамок
2) width:100% - ширина содержания сблока равна ширине родительского блока, отступы и рамки выпадают за ширину родительского элементаю

<!-- Проблемы блочной верстки, при задании  -->

Всё дело в классической блочной модели, в которой размеры указываются содержимому блока, а не блоку в целом

box-sizing - задает тип обработки ширины.
  - content-box - значение по умолчанию, соответвует стандартной блочной модели.
  - border-box - изменяет режим расчета ширины элемента, которое позволяет не учитывать в размерах блока отступы и границы. Таким образом, указывая размеры блоку, вы указываете их всему блоку, а не содержимому.

  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;

  http://simonenko.su/32197993404/use-css3-box-sizing

<!-- Display -->

Задание типа отображения элемента
  - block - блочный элемент, до и после него перенос строки
  - inline - не воспринимают размеры
  - inline-block  
    - им можно задавать размеры рамки и отступы как блочным
    - ширина зависит от содержания, и не растягивается на всю ширину контейнера,
    - не порождают принудительных переносов
    - выравниваются вертикально подобно строчным элементам
  - table
    - ширина зависит от содержания
    - можно задавать ширину высоту рамки и отступы    
    - переносы до и после элемента
    - border-spacing отступы между ячейками
  - table-row
    - необычный элемент, является контейнером для ячеек и практически не имеет собственного отображения.
  - table-cell
    - если здачать элементу тип cell, браузер создаст во круг него дополнительные елементы row\table, минус в том что вы не сможете ими управлять.
  - none
    - элемент не отображается
    - не занимает места на странице(в отличие от visibility: hidden)

<!-- Position -->
  Понятие потока документа.
  Задает режим позиционирования элементов, по умолчанию static

  - static (обычное позиционировани)
  - relative (относительное позиционирование) 
    - top\left\bottom\right - смещение проекции относительно исходного положения
  - absolute 
    - выпадают из потока документа, место которое занимали становится пустым, его занимают другие желементы
    - top\left\bottom\right - смещение проекции относительно родительского элемента с относительным позиционированием или окна браузера (позволят адекватно прижать элемент к правой\нижней части экрана)        
    - ширина по умолчанию зависит от содержимого
    - отстаются на изчанальном месте если не заданы top\left\bottom\right

  Абсолбтное позиционирование, изменяет поведение блочных и строчных элементов, строчные элементы относительно спозиционированные ведутя себя так же как и блочные,   появляется возможность задать ширину и высоту.

  Можно сказать, что есть еще один тип элементов — абсолютно спозиционированные. Такими становятся элементы всех остальных типов (блочные, строчные, блочно-строчные и т.д.), если им задано свойство position:absolute;.

  Неявная точка отсчета - это место, где находится элемент до того, как ему задали абсолютное позиционирование, если "абсолютному" элементу не задавать свойства left...bottom, он выпадет из потока но останется на прежнем месте, такой элемент можно сместить с помощью свойства margin, оно будет работать так же, как и свойство margin для "относительного" элемента, если left...bottom не задано, по умолчанию auto, с помощью auto можно возвращать "абсолютные элементы" на изначальное место

  На практике абсолютное позиционирование часто применяют в декоративных целях, когда нужно аккуратно разместить какие-либо иконки, управляющие элементы или другие «рюшечки».

  "Абсолютный" элемент выпадает из потока, но остается на том же месте, где был расположен до этого


  - fixed
    - выпадает из потока
    - привязывается к окну браузера
    - не скроллится
    - left\top\bottom\right - смещение относительно окна браузера

<!-- z-index -->
По умолчанию выше оказывается тот блок, которы расположен дальше в коде страницы
Чем больше z-index, тем выше распологается блок
Работает для absolute, fixed и relative, но не для static, таким образом относительно отпозиционированный блок может перекрыть в абсолютно отпозиционированный.
z-index работает в пределах конкретного контекста наложения
Новый контекст наложения может быть:
- корневой елемент документа html
- если элемент позиционирован не статически и его значение z-index не равно авто
- если элемент имеет прозрачность менее 1


<!-- Сетка - поток документа -->

Поток - это порядок отображения элементов на странице. По умолчанию блочные элементы отображаются как прямоугольные области, идущие жруг за другом сверху вниз, а строчные элементы располагаются сверху вних и слева направо и при неоюходимости переносятся на новую строку.

Потоком можно управлять и изменять стандартное поведение элементов в потоке. Возможно заcтавить двигатся блочные элементы не сверху вниз, а выстраиватся в неcколько колонок.

Что нужно уметь, чтобы строить сетки:
1) управлять размером элементов
2) управлять поведение элементов в потоке

float: left\right; - прижимает элемент к определенным областям.
clear: both \ left \ right; - no floating elements allowed on the right or left side 

Сетка - это взаимное расположение крупных блоков сайта

Для построения сетки необходимо:
- управлять размерами элементов;
- управлять поведением элементов в потоке;  

Спобосы строить сетки:
- float;
- table;
- inline-block;
- flex-box;

Табличная верстка - самый простой способ построения сеток. Но он считается устаревшим и использовать его не рекомендуется, в будущем можно будет использовать для такой вестки не таблицы, а элементы с типом display: table \ display: table-row \ display: table-cell;

Флекс-боксы - это новая и интересная технология. К сожалению, ее поддержка браузерами еще достаточно слабая.

Флоаты - самый распостраненный способ построения сеток.

Режим обтекания элемента (float):
- left (прижимает элемент к левому краю, другие элементы обтикают его справа)
- right (прижимает элемент к правому краю, другие элементы обтикают его слева)
- none (значение по умолчанию, отклбчает режим обтикания)
    
В отличие от позиционирования, которым можно двигать блоки в произвольном порядке, все что может float - сдвинуть элемент к одной из сторон потока, правой или левой. При этом float'нутый бокс смещается по горизонтали и прилепает к одной из сторон родителя.

По умолчанию блочные элументы растягиваются на всю доступную ширину родителя

Зафлоаченый бокс прижимается к краю, и начинает ужиматься по ширине под свое содержимое. Заfloa'ченному элементу можно явно задавать отсутпы и размеры.
Если зафлоатить строчный элемент, он начинает вести себя как блочный, а именно: воспринимает размеры и отступы

Зафлоаченый бокс перестает раздаватся на всю ширину родительского бокса-контейнера

Следующие за зафлоаченым боксом элементы подтягиваются вверх и занимают его место, как если бы флоатнуго бокса не было. Строчные элементы подтягиваются на верх и начинают обтикать флоатнутый бокс со свободной стороны.

Зафлоаченные элементы выпадают из потока, но лишь частично:

- блочные элементы, которые идут в коде полсе зафлоаченного блока, перестают его замечать. Они подтягиваются вверх и занимают его место, как будто его и нет.
- сторочные элементы начинают его обтекать со свободной стороны.

Такое поведение флоатов дает следующие эффекты:
1) прохождение сквозь блоки, появляется когда зафлоаченный элемент выше, чем несколько последующих за ним блоков.
2) эффект выпадания из родителя и схлопывания родителя, появляется в том случае если все дочерние элементы в родителе зафлоачены, в этом случае родитель схлопывается по высоте, как будто в нем нет содержимого, а блоки выпадают из него.

Флоаченные элементы видят друг друга, идущие другза другом флоаты выстраиваются в ряд, пока им не хватает места, если места не хватает, то они переносятся на следующую строку, почти как текст. Эта оссобенность позволила применять их для создания сеток. В начале двухтысячных небыло другого способа создавать колонки и задавать из разсеры.

Блочные элементы всегда распологались в разных строках. Сточные могли распологатся на одной строке, но совершенно не воспринимали размеры. Позиционирование тоже не подходило для сеток, т.к. элементы выпадали из потока.

Поведение нескольких флоатов в случа если места на одной строке нехватает является очень странным. Когда флоат переносится на следующую строку, возможно несколько вариантов и не все их них логичны. Например, флоат может зацепится за один из предвешствующих флоатов или встать ниже не в самом началестроки, а за предшествующим, эти приемы повлияли на приемы испольвания флоатов в создании раскладок.

Для того чтобы зафлоаченный бокс мог обтекатся обычным, он должен в коде распологатся выше обычного.

clear - запрещает обтекание элемента другими элементами
значения:
left\right\both\none

Если после флоатного элемента расположен элемент с запрещенным обтеканием, то последний опускается под флоатнутый.
clear - учит блочные элементы видеть зафлоаченные.

Распорки

Эффект выпадения флоатов из родителей большая проблема при построении сеток. Т.к. сетки на флоатах обычно делаются вот так:
1) создается блок контейнер для колонок
2) в контейнер добавляются флоатные блоки-колонки.
3) рассчитывается ширина колонок так, чтобы им хватало места в родителе

Если у контейнера есть фон, отличный от фона страницы. Тогда колонки выпадали, родитель схлопывался и фон пропадал.
необходимо было найти способ борьбы с выпаданием. Тут и пригодилось свойство clear:both

<!-- Пример старого решения -->

<div class="container"> - блок-контейнер
    <div class="column1">...</div> - колонка, флоат
    <div class="column2">...</div> - колонка, флоат
    <div class="clearfix"></div> - распорка с clear:both
</div>

Т.е. начали добавлять после зафлоаченных колонок пустой элемент-распорку со свойством clear: both. Этот элемент видел колонки и не давал пройти через себя, а заодно и растягивал родительский блок по высоте.

Для таких распорок прижилось специальное название класса - clearfix

Поддержка псевдоэлементов позволила избавится от лишнего clearfix элемента

<!-- Примененине распорки с псевдоклассами -->

Псевдоэлементы позволяют с помощью CSS вставить в структуру HTML-документа узлы, которых нет в HTML коде, благодаря чему возможно решение проблемы флоатов без использования дополнительного элемента.

.clearfix:after{
    content:'';
    display:block;
    clear:both;
}

Приём с дополнительными блоками, которые позиционируют содержание, чтобы родительские блоки могли тянуться на всю ширину окна, достаточно распространён. Дизайн с подобными сетками тоже встречается очень часто.

<!-- Прием с блоком layout -->

.layout-positioner{
    width: X;
    margin:0 auto;
    border:2px dashed #3498db;
}
.layout-positioner:after{
    content:'';
    clear:both;
    display:table;
}

<!-- Погружение в inline-block -->

Блочно-строчные элементы ведут себя двояко, с наружи они ведут себя как строчные, внутри как блочные

От строчных:
- ужимаются по ширине под свое содержание
- могут распологатся на всю строку
- реагируют на вертикальное выравнивание vertical-align
- реагируют на горизонтальное выравнивание, text-align, заданное у родителя

От блочных:
- им можно задать размеры с помощью width and height
- также внешние\внутренние отступы и рамки, которые работают по всех направления и увеличивают размер элемента

Блочно-строчные жлементы могут выстраиватся друг за другом, а если не хватает места, то они переносятся на след строку.

Поведение похожее на флоат, но есть существенное различие

При переносе на следующую строку блочно-строчные ведут себя намного логичнее. Высота строк у них расчитывается по максимальному элементу с учетом отступов.

.item:nth-child(3n)

Блочнострочные не поддерживаются IE7

<!-- Important -->

Блочнострочные элементы ведут себя как текст, поэтому если в коде есть пробел, то он отображается и на странице, этот проблем увеличивает отступы между блочнострочными

Бороться с пробелом после блочно-строчных можно несколькими способами:

- удалять пробелы в коде;
- обнулять размер шрифта(задается нулевой размер шрифта у контейнера, у самих блоков шрифт остается нормальным, спомоб не работает если использовать относительные размеры шрифта);
- играться с маргинами после блочно-строчног(уменьшаем оступ после инлайн блока на ширину плобела равную 4px, а если нужно чтобы элементы стояли в плотную - задаем отрицательный оступ, проблема заключается в том, размер пробела может менятся в зависимости от шрифта и при изменении шрифта).

https://htmlacademy.ru/blog/21
http://css-live.ru/articles/zagadochnye-otstupy-mezhdu-inlajn-blokami.html

<!-- Backgrounds -->

Если элементу задать одновлеменно цвет и фотовую картинку, в этом случае картинка будет отображатся поверх фонового цвета

background-image: url('url');
background-color: color;

По умолчанию фоновое изображение повторяется. Это заметно когда оно меньше блока.
background-repeat: repeat | repeat-x | repeat-y |no-repeat;

Свойство background-position управляет расположением фонового изображения, значения свойства состоит из двух частей, разделенных пробелом: x y, - где x- , а y- значение по вертикали
x (по горизонтали) - принимает аргументы: left | center | right | (проценты)% | (пиксели)px
y (по вертикали) - принимает аргументы: top | center | bottom | (проценты)% | (пиксели)px

значения могут принимать относительные значения(проценты), а иногда абсолютные(пиксели), как положительные так и отрицательные, к тому же можно комбинировать пиксели и проценты.

Примеры:
background-position: 50% 50%; (картинка по центру)
background-position: right bottom; (правый нижний угол)
background-position: 50px 100px; (отсутпы от левого края 50px и 100px от верхнего)
background-position: 0 100%; (левый нижний угол)
background-position: left bottom; (левый нижний угол)

Когда фоновое изображение больше бока - оно брезается, управлять поведением можно с помощью backgroud-position

background-attacment: scroll(фон прокручивается вместе с содержимым) | fixed(фон фиксируется)


Сокращенная форта
background: [bc] [bi] [br] [bp] [ba];
bc - color(по умолчанию прозрачный)
bi - image
br - repeat(по умолчанию во все стороны)
bp - position(по умолчанию левый верхний угол)
ba - attachment

JPEG - подходит для 

-----------------------------

hack!

div {
    display: none;
}
    
a:hover + div {
    display: block;
}

:visited
:active
:link
-----------------------------

Начнем с того, что все, что делается таблицами, делается и CSS (просто надо не лениться и прочитать соответствующие руководства). У таблиц есть недостатки: 

— нельзя перегруппировать блоки для узких страниц или в версии для печати только с помощью CSS
— если мы выводим список картинок таблицей, каждая картинка в ячейке, то при добавлении или удалении картинки оставшиеся не сдвигаются, а остается пустое место
— у ячеек width работает как min-width, при этом алгоритмы ратяжения ячеек не документированы и ведут себя непредсказуемо, из-за этого они могут непредсказуемо растягиваться, и хуже того, при динамической замене контента они не всегда сжимаются обратно и остаются дыры. Одно длинное слово или картинка может растянуть всю страницу.
— фиксированное, абсолютное и относительное позиционирование неюзабельно в таблицах
— ячейки не получится перетаскивать drag-n-drop
— трудно манипулировать DOM (надо хитро вставлять и убирать дополнительные элменеты)
— верстка получается замусоренная кучей лишних тегов, которые тяжело читать и в которых тяжело разобраться. Это не HTML, а лапша. Особенно тяжело, когда таблицы вложены друг в друга и раскиданы по куче шаблонов.
— нельзя поместить контент в коде первым, а меню в шапке — вторым (некоторые сеошники считают, что это улучшает индексацию)
— верстка таблицами всегда была костылем (и это несемантично), с поддержкой CSS2 (появилась более 10 лет назад) таблицы стали не нужны. 10 лет назад они уже стали ненужными.

  
