#Table of contants
## Что такое абстракция, абстрагирование и уровни абстракциии

> Программные проекты слишком разнообразны, а разработка ПО слишком сложна, чтобы существовал единственный подход, одинаково хорошо подходящий всем.
> "Agile!: The Good, the Hype and the Ugly"

> Лично для меня каждая из приведенных выше составляющих очень важна. Если посмотреть внимательно на развитие нашей отрасли, то легко можно заметить, что она эволюционирует и строится на базе знаний и опыта, полученных ранее. И гибкие методы, тоже не являются в этом плане исключением. Так, например, итеративная разработка появилась в 70-х, труды по управлению требованиями и идея непрерывной интеграции – в 80-х, критика классического "водопада", опасности переработок, важности коммуникаций и того раньше. Таким образом, можно сказать, что гибкие методы – это очередной виток эволюции в разработке ПО, который делает акцент на определенном наборе практик, не столь популярных ранее, и уменьшает важность других практик, без которых разработка ПО считалась невозможной.

> В управлении проектами точно также полезно понимать "на один уровень абстракции ниже", чтобы вместо слепого следования предложенным принципам знать, когда они действительно нужны, когда их можно временно проигнорировать, и когда их не стоит использовать вообще, поскольку они не подходят для вашей команды или проекта.

> С другой стороны, любой сложный проект будет требовать узкой квалификации в определенных областях; не эффективно спрашивать неспециалиста помочь с задачей в такой области, где он обязательно напортачит или будет постоянно отвлекать соответствующего эксперта. В этом случае значительно эффективнее дождаться, когда эксперт освободится и решит проблему самостоятельно.

> Одной из классических проблем в разработке ПО является проблема изменения требований. Все мы знаем, что наш заказчик не знает, чего он хочет, более того, даже если он считает, что он это знает, то его мнение обязательно изменится в будущем. Именно поэтому мы используем короткие итерации, иногда создаем прототипы и стараемся проектировать решение таким образом, чтобы изменения требований не привели к тотальной переделке системы.

> При этом конкретные методологии разработки, например, XP (eXtreme Programming) предлагают конкретные решения, как обеспечить выполнение данного принципа: "начинайте с самого простого рабочего решения и усложняйте его лишь тогда, когда этого будут требовать тесты" (start with the simple thing that could possible work and add complexity only when it's required by tests) (еще одно описание простоты см. в "Simplicity is the Key").

> Бертран Мейер в своей книге дает достаточно формальное определение того, что такое принцип (разработки, проектирования), и чем от отличается от практики. Так вот, принцип – абстрактен, а практика – конкретна. Так, например, "будьте готовы к изменениям требованиям" – это принцип, а "используйте самое простое решение для достижения расширяемости системы" – это практика.

> Несмотря на то, что совет по поводу простоты очень правильный, но он не такой простой, как кажется! (pun intended). У Рича Хики есть замечательное выступление, под названием "Simple Made Easy", о котором я писал как-то в Г+, в котором отлично показано, что "простота" (simplicity) – это не одно и тоже, что и "легкость" (easiness). Простое решение обычно отличается элегантностью и отсутствием лишнего, а легкое решение зачастую бывает примитивным и тяжелым для сопровождения, но самым легким в достижении.

> Негативный эффект от таких заявлений усиливается тем, что фундаментальная проблема изменений программного обеспечения является архитектурной. Простота изменений не возникает из воздуха: для этого архитектура решения должна быть спроектирована соответственно. Хорошие учебники учат этому, но такие Big Upfront задумки рьяно отвергаются сторонниками гибких методов.

> В данном конкретном случае очень важно отличать принцип (абстрактную цель), от практики (конкретного способа достижения этой цели). Кент Бек предлагает использовать TDD и рефакторинг, но это не значит, что он запрещает вам вначале порисовать дизайн на бумаге, набросать контракты, добавить несколько тестов, а затем перейти к обобщению решения.

> Гибкие методы являются бесспорно одним из наиболее важных достижений в разработке ПО за последнее время. К тому же, они являются удивительной смесью лучшего и худшего.

> Все знают, что читать хорошо и полезно. Некоторые особо активные товарищи рекомендуют поставить себе цель, например, читать 25 книг в год. Поскольку это и правда полезно, а цели делают жизнь интереснее, то я решил воспользоваться этим же советом и поставил себе цель в виде goodreads challenge (https://www.goodreads.com/user_challenges/1369203).

> Теперь что получается: мне нужно читать 2 книги в месяц, и сейчас я уже отстаю на одну книгу. И хотя я никому ничего не обещал, этот challenge начинает оказывать на меня психологическое давление, что, в свою очередь, начинает оказывать влияние на выбор книги. Так, например, я прекрасно знаю, что на алгоритмы Кормена у меня уйдет 6-9 месяцев, что накроет мою цель медным тазом. Поэтому я иногда выбираю не только книги, которые я очень хочу прочесть, но еще и те, которые я смогу прочесть относительно быстро.

> Какая связь с гибкими методологиями? ИМХО, достаточно прямая. Требование видимого результата может оказывать влияние на команду и выбор задач, аналогично тому, как «двухнедельные спринты» оказывают влияние на выбор моих книг. Конечно, зная об этой опасности я могу фильтровать книги, все же выбирая одну-две тяжелые книги за определенный период. Аналогично, команда может осознавать эту опасность и спокойно чередовать видимые результаты с фундаментальными вложениями в архитектуру приложения.
Главный посыл книги Мейера (как и мой, впрочем) в том, что к любой методологии подходить с холодной головой, стараясь понять все за и против. Второй посыл Мейера в том, что не нужно кидаться из крайности в крайность. Есть новые веяния, но есть же и проверенные временем подходы. В гибких подходах есть огромное количество полезных и разумных принципов, но ведь есть и такие, которые легко использовать неправильно, особенно если понимать их сильно буквально.
Вот, минимализм – это один из таких принципов. Принцип-то хорош, но нужно четко понимать, к чему он приведет, и какие риски содержит. Вот и все.

> A good methodological principle is both abstract and falsifiable. Abstractness differentiates principles from practices; falsifiability distinquishes them from platitudes (банальность). Abstractness means that principle should be general rule, not a specific practice. "Build a solid financial foundation for the future" is a principle; "Put 10% of your earnings every month into a savings account" is a practice. Often a practice exists to help satisfy a principle. Falsifiability (фальсифицируемость) means that it must be possible for a reasonable person to disagree with the principle. If no one in his right mind would ever disagree with a proposed rule, as with "seek software quality" (who would advocate not seeking quality in developing software?), then it may be right but it also uninteresting. For the rule to be a principle, you must be able - regardless of your own opinion - to ensision someone supporting its negation. "Test first" satisfies this criterion: it is possible to argue that programs should be written before tests, or that specification rather than tests should precede the program. A rule whose negation is unsustainable, such as "seek software quality", is not a principle but a platitude.

> Ведь именно из-за того, что в нескольких предыдущих проектах проектированию уделили слишком мало времени, в итоге система переписывалась на 40-60%%, а среднестатистический мыслящий программист не любит делать одно и то же по многу раз, вот и «приходится» уделять больше времени на предварительный анализ. И именно тут его начинают интересовать такие аспекты разработки ПО как объектно-ориентированный анализ и проектирование.

> Код чаще читается, чем пишется

> In computer programming, cohesion refers to the degree to which the elements of a module belong together.[1] Thus, cohesion measures the strength of relationship between pieces of functionality within a given module. For example, in highly cohesive systems functionality is strongly related.

> Cohesion is an ordinal type of measurement and is usually described as “high cohesion” or “low cohesion”. Modules with high cohesion tend to be preferable, because high cohesion is associated with several desirable traits of software including robustness, reliability, reusability, and understandability. In contrast, low cohesion is associated with undesirable traits such as being difficult to maintain, test, reuse, or even understand.

> каким образом нужно писать код, правильно реагируя на приходящие требования